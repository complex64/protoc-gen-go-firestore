// Code generated by protoc-gen-go-firestore. DO NOT EDIT.
// versions:
// 	protoc-gen-go-firestore 1.2.0
// 	protoc          (unknown)

package unlinked

import (
	firestore "cloud.google.com/go/firestore"
	context "context"
	errors "errors"
	iterator "google.golang.org/api/iterator"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

type FS_unlinked struct {
	client *firestore.Client
}

func Firestore(client *firestore.Client) *FS_unlinked {
	return &FS_unlinked{
		client: client,
	}
}

func (x *FS_unlinked) Parents() *FS_unlinked_Parents {
	return &FS_unlinked_Parents{
		c: x.client.Collection("parents"),
	}
}

type FS_unlinked_Parents struct {
	c *firestore.CollectionRef
}

type FS_unlinked_Parents_Iter struct {
	i *firestore.DocumentIterator
}

type FS_unlinked_Parents_Query struct {
	q firestore.Query
}

func (x *FS_unlinked_Parents_Query) Documents(ctx context.Context) *FS_unlinked_Parents_Iter {
	return &FS_unlinked_Parents_Iter{
		i: x.q.Documents(ctx),
	}
}

func (x *FS_unlinked_Parents_Query) Value() firestore.Query {
	return x.q
}

func (x *FS_unlinked_Parents) Where(path, op string, value interface{}) *FS_unlinked_Parents_Query {
	return &FS_unlinked_Parents_Query{
		q: x.c.Where(path, op, value),
	}
}

func (x *FS_unlinked_Parents_Query) Where(path, op string, value interface{}) *FS_unlinked_Parents_Query {
	return &FS_unlinked_Parents_Query{
		q: x.q.Where(path, op, value),
	}
}

func (x *FS_unlinked_Parents) OrderBy(path string, dir firestore.Direction) *FS_unlinked_Parents_Query {
	return &FS_unlinked_Parents_Query{
		q: x.c.OrderBy(path, dir),
	}
}

func (x *FS_unlinked_Parents_Query) OrderBy(path string, dir firestore.Direction) *FS_unlinked_Parents_Query {
	return &FS_unlinked_Parents_Query{
		q: x.q.OrderBy(path, dir),
	}
}

func (x *FS_unlinked_Parents) Limit(n int) *FS_unlinked_Parents_Query {
	return &FS_unlinked_Parents_Query{
		q: x.c.Limit(n),
	}
}

func (x *FS_unlinked_Parents_Query) Limit(n int) *FS_unlinked_Parents_Query {
	return &FS_unlinked_Parents_Query{
		q: x.q.Limit(n),
	}
}

func (x *FS_unlinked_Parents_Iter) Stop() {
	x.i.Stop()
}

func (x *FS_unlinked_Parents) Doc(id string) *FS_unlinked_Parents_Doc {
	return &FS_unlinked_Parents_Doc{
		d: x.c.Doc(id),
	}
}

type FS_unlinked_Parents_Doc struct {
	d *firestore.DocumentRef
}

func (x *FS_unlinked_Parents_Doc) Subparents() *FS_unlinked_Parents_Subparents {
	return &FS_unlinked_Parents_Subparents{
		c: x.d.Collection("subparents"),
	}
}

type FS_unlinked_Parents_Subparents struct {
	c *firestore.CollectionRef
}

type FS_unlinked_Parents_Subparents_Iter struct {
	i *firestore.DocumentIterator
}

type FS_unlinked_Parents_Subparents_Query struct {
	q firestore.Query
}

func (x *FS_unlinked_Parents_Subparents_Query) Documents(ctx context.Context) *FS_unlinked_Parents_Subparents_Iter {
	return &FS_unlinked_Parents_Subparents_Iter{
		i: x.q.Documents(ctx),
	}
}

func (x *FS_unlinked_Parents_Subparents_Query) Value() firestore.Query {
	return x.q
}

func (x *FS_unlinked_Parents_Subparents) Where(path, op string, value interface{}) *FS_unlinked_Parents_Subparents_Query {
	return &FS_unlinked_Parents_Subparents_Query{
		q: x.c.Where(path, op, value),
	}
}

func (x *FS_unlinked_Parents_Subparents_Query) Where(path, op string, value interface{}) *FS_unlinked_Parents_Subparents_Query {
	return &FS_unlinked_Parents_Subparents_Query{
		q: x.q.Where(path, op, value),
	}
}

func (x *FS_unlinked_Parents_Subparents) OrderBy(path string, dir firestore.Direction) *FS_unlinked_Parents_Subparents_Query {
	return &FS_unlinked_Parents_Subparents_Query{
		q: x.c.OrderBy(path, dir),
	}
}

func (x *FS_unlinked_Parents_Subparents_Query) OrderBy(path string, dir firestore.Direction) *FS_unlinked_Parents_Subparents_Query {
	return &FS_unlinked_Parents_Subparents_Query{
		q: x.q.OrderBy(path, dir),
	}
}

func (x *FS_unlinked_Parents_Subparents) Limit(n int) *FS_unlinked_Parents_Subparents_Query {
	return &FS_unlinked_Parents_Subparents_Query{
		q: x.c.Limit(n),
	}
}

func (x *FS_unlinked_Parents_Subparents_Query) Limit(n int) *FS_unlinked_Parents_Subparents_Query {
	return &FS_unlinked_Parents_Subparents_Query{
		q: x.q.Limit(n),
	}
}

func (x *FS_unlinked_Parents_Subparents_Iter) Stop() {
	x.i.Stop()
}

func (x *FS_unlinked_Parents_Subparents) Doc(id string) *FS_unlinked_Parents_Subparents_Doc {
	return &FS_unlinked_Parents_Subparents_Doc{
		d: x.c.Doc(id),
	}
}

type FS_unlinked_Parents_Subparents_Doc struct {
	d *firestore.DocumentRef
}

func (x *FS_unlinked_Parents_Subparents_Doc) Items() *FS_unlinked_Parents_Subparents_Items {
	return &FS_unlinked_Parents_Subparents_Items{
		c: x.d.Collection(FirestoreCollectionItems),
	}
}

type FS_unlinked_Parents_Subparents_Items struct {
	c *firestore.CollectionRef
}

type FS_unlinked_Parents_Subparents_Items_Iter struct {
	i *firestore.DocumentIterator
}

type FS_unlinked_Parents_Subparents_Items_Query struct {
	q firestore.Query
}

func (x *FS_unlinked_Parents_Subparents_Items_Query) Documents(ctx context.Context) *FS_unlinked_Parents_Subparents_Items_Iter {
	return &FS_unlinked_Parents_Subparents_Items_Iter{
		i: x.q.Documents(ctx),
	}
}

func (x *FS_unlinked_Parents_Subparents_Items_Query) Value() firestore.Query {
	return x.q
}

func (x *FS_unlinked_Parents_Subparents_Items) Where(path, op string, value interface{}) *FS_unlinked_Parents_Subparents_Items_Query {
	return &FS_unlinked_Parents_Subparents_Items_Query{
		q: x.c.Where(path, op, value),
	}
}

func (x *FS_unlinked_Parents_Subparents_Items_Query) Where(path, op string, value interface{}) *FS_unlinked_Parents_Subparents_Items_Query {
	return &FS_unlinked_Parents_Subparents_Items_Query{
		q: x.q.Where(path, op, value),
	}
}

func (x *FS_unlinked_Parents_Subparents_Items) OrderBy(path string, dir firestore.Direction) *FS_unlinked_Parents_Subparents_Items_Query {
	return &FS_unlinked_Parents_Subparents_Items_Query{
		q: x.c.OrderBy(path, dir),
	}
}

func (x *FS_unlinked_Parents_Subparents_Items_Query) OrderBy(path string, dir firestore.Direction) *FS_unlinked_Parents_Subparents_Items_Query {
	return &FS_unlinked_Parents_Subparents_Items_Query{
		q: x.q.OrderBy(path, dir),
	}
}

func (x *FS_unlinked_Parents_Subparents_Items) Limit(n int) *FS_unlinked_Parents_Subparents_Items_Query {
	return &FS_unlinked_Parents_Subparents_Items_Query{
		q: x.c.Limit(n),
	}
}

func (x *FS_unlinked_Parents_Subparents_Items_Query) Limit(n int) *FS_unlinked_Parents_Subparents_Items_Query {
	return &FS_unlinked_Parents_Subparents_Items_Query{
		q: x.q.Limit(n),
	}
}

func (x *FS_unlinked_Parents_Subparents_Items_Query) First(ctx context.Context) (*Item, error) {
	iter := x.q.Limit(1).Documents(ctx)
	defer iter.Stop()
	snap, err := iter.Next()
	if err != nil {
		if errors.Is(err, iterator.Done) {
			return nil, nil
		}
		return nil, err
	}
	o := new(FirestoreItem)
	if err := snap.DataTo(o); err != nil {
		return nil, err
	}
	if p, err := o.ToProto(); err != nil {
		return nil, err
	} else {
		return p, nil
	}
}

func (x *FS_unlinked_Parents_Subparents_Items_Iter) GetAll() ([]*Item, error) {
	snaps, err := x.i.GetAll()
	if err != nil {
		return nil, err
	}
	protos := make([]*Item, len(snaps))
	for i, snap := range snaps {
		o := new(FirestoreItem)
		if err := snap.DataTo(o); err != nil {
			return nil, err
		}
		if p, err := o.ToProto(); err != nil {
			return nil, err
		} else {
			protos[i] = p
		}
	}
	return protos, nil
}

func (x *FS_unlinked_Parents_Subparents_Items_Iter) GetAllAsSnapshots() ([]*firestore.DocumentSnapshot, error) {
	return x.i.GetAll()
}

func (x *FS_unlinked_Parents_Subparents_Items_Iter) Next() (*Item, error) {
	snap, err := x.i.Next()
	if err != nil {
		return nil, err
	}
	o := new(FirestoreItem)
	if err := snap.DataTo(o); err != nil {
		return nil, err
	}
	if p, err := o.ToProto(); err != nil {
		return nil, err
	} else {
		return p, nil
	}
}

func (x *FS_unlinked_Parents_Subparents_Items_Iter) NextAsSnapshot() (*firestore.DocumentSnapshot, error) {
	return x.i.Next()
}

func (x *FS_unlinked_Parents_Subparents_Items_Iter) Stop() {
	x.i.Stop()
}

func (x *FS_unlinked_Parents_Subparents_Items) Create(ctx context.Context, p *Item) (*firestore.WriteResult, error) {
	fs, err := p.ToFirestore()
	if err != nil {
		return nil, err
	}
	id := fs.Name
	if id == "" {
		return nil, status.Error(codes.InvalidArgument, "empty id")
	}
	res, err := x.c.Doc(id).Create(ctx, fs)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (x *FS_unlinked_Parents_Subparents_Items) Doc(id string) *FS_unlinked_Parents_Subparents_Items_Doc {
	return &FS_unlinked_Parents_Subparents_Items_Doc{
		d: x.c.Doc(id),
	}
}

type FS_unlinked_Parents_Subparents_Items_Doc struct {
	d *firestore.DocumentRef
}

func (x *FS_unlinked_Parents_Subparents_Items_Doc) Get(ctx context.Context) (*Item, error) {
	snap, err := x.d.Get(ctx)
	if err != nil {
		return nil, err
	}
	o := new(FirestoreItem)
	if err := snap.DataTo(o); err != nil {
		return nil, err
	}
	if p, err := o.ToProto(); err != nil {
		return nil, err
	} else {
		return p, nil
	}
}

func (x *FS_unlinked_Parents_Subparents_Items_Doc) Set(ctx context.Context, m *Item) error {
	fs, err := m.ToFirestore()
	if err != nil {
		return err
	}
	if _, err := x.d.Set(ctx, fs); err != nil {
		return err
	}
	return nil
}

func (x *FS_unlinked_Parents_Subparents_Items_Doc) Delete(ctx context.Context, preconds ...firestore.Precondition) (*firestore.WriteResult, error) {
	return x.d.Delete(ctx, preconds...)
}

func (x *FS_unlinked_Parents_Subparents_Items_Doc) Ref() *firestore.DocumentRef {
	return x.d
}
